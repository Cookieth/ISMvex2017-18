#pragma config(Sensor, in1,    potSensor,      sensorPotentiometer)
#pragma config(Sensor, in2,    rightLiftSensor, sensorPotentiometer)
#pragma config(Sensor, in3,    leftLiftSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl7,  ArmLimit,       sensorTouch)
#pragma config(Sensor, dgtl8,  ElbowLimit,     sensorTouch)
#pragma config(Sensor, dgtl9,  RightBottomEnc, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftBottomEnc,  sensorQuadEncoder)
#pragma config(Motor,  port2,           leftMotors,    tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightMotors,   tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           leftArm,       tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           rightArm,      tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           lifters,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           elbow,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

//Motor on values
static int leftMotorsVal = 127;
static int rightMotorsVal = 127;
static int initRightEncoder = 0;
static int initLeftEncoder = 0;
static int rightEncoder;
static int leftEncoder;


//Central Functions Section
void controllerBasic();
void turnAround();

//Drive Controller Section
void allOff();
void motorForward();
void motorBackward();
void motorLeftOn();
void motorRightOn();
void motorPointC();
void motorPointCC();
void resetEncoders();
void updatePowers();
void driveFunct(int direction, int duration);
void driveUntil(int right, int left);
int abs(int n);
void compAuton();
void skillsAuton();
void setupAuton();

//==================================================================================================
//                     		      T A S K   S E C T I O N
//--------------------------------------------------------------------------------------------------
//			FUNCTIONS:
//				PRE_AUTON
//				AUTONOMOUS
//				USER CONTROL
//==================================================================================================

void pre_auton()
{
	//I DON'T THINK I'M DOING ANYTHING HERE
}

task autonomous()
{

	//1 = Forward
	//2 = Backward
	//3 = MOTOR Left
	//4 = MOTOR Right
	int forward = 1;
	int backward = 2;
	int left = 3;
	int right = 4;
	int pointC = 5;
	int pointCC = 6;
	int liftersUP = 7;
	int liftersDOWN = 8;
	int armsUP = 9;
	int armsDOWN = 10;

	//SKILLS:
	if(SensorValue[potSensor] < 2000){
		skillsAuton();
	}

	//COMP:
	else {
		compAuton();
	}
}

task usercontrol(){
	while (true){
		controllerBasic();
	}
}

//==================================================================================================
//                           C E N T R A L   F U N C T I O N S   S E C T I O N
//--------------------------------------------------------------------------------------------------
//			MAIN FUNCTIONS:
//				1. CONTROLLER BASIC (119)
//				2. DRIVE FUNCT (246)
//				3. DRIVE UNTIL (319)
//				4. COMP AUTON (377)
//				5. SKILLS AUTON (409)
//
//			CONTROLLER INDEX:
//				1. DRIVE CONTROLLER SECTION (200)
//				2. ENCODER CONTROLLER SECTION (288)
//				3. AUTONOMOUS CONTROLLER SECTION (374)
//==================================================================================================

void controllerBasic(){

	//========
	//BASE
	if(vexRT[Btn8U] == 1) {
		resetEncoders();
	}
	else if(vexRT[Btn8D] == 1) { //test button for competition autonomous
		compAuton();
	}
	else if(vexRT[Btn7U] == 1) {
		motorForward();
	}
	else if(vexRT[Btn7D] == 1) {
		motorBackward();
	}
	else if(vexRT[Btn7L] == 1) {
		motorPointCC();
	}
	else if(vexRT[Btn7R] == 1) {
		motorPointC();
	}
	else {
		motor[leftMotors] = vexRT(Ch3);
		motor[rightMotors] = vexRT(Ch2);
	}

	//========
	//LIFTERS
	if(vexRT[Btn5U] == 1 || vexRT[Btn5UXmtr2] == 1){
		if(SensorValue[leftLiftSensor] < 2240 || SensorValue[rightLiftSensor] < 4050) { //values ensure lifters don't sratch motor
			motor[lifters] = 127;
		}
		else {
			motor[lifters] = 0;
		}
	}
	else if(vexRT[Btn5D] == 1 || vexRT[Btn5DXmtr2] == 1){
		if(SensorValue[leftLiftSensor] > 940 || SensorValue[rightLiftSensor] > 2550) { //values ensure lifters don't sratch floor
			motor[lifters] = -127;
		}
		else {
			motor[lifters] = 0;
		}
	}
	else{
		motor[lifters] = 0;
	}

	//========
	//ARMS
	if(SensorValue[ArmLimit] == 1 && vexRT(Ch3Xmtr2) > 0) { //if sensor is pressed and arm is not to move down
		motor[leftArm] = 0;
		motor[rightArm] = 0;
	}
	else {
		motor[leftArm] = vexRT(Ch3Xmtr2);
		motor[rightArm] = vexRT(Ch3Xmtr2);
	}

	//=========
	//ELBOW and CLAW
	if(SensorValue[ElbowLimit] == 1 && vexRT(Ch2Xmtr2) > 0) { //if sensor is pressed and elbow is not to move down
		motor[elbow] = 0;
	}
	else {
		motor[elbow] = vexRT(Ch2Xmtr2);
	}

	if(vexRT[Btn6UXmtr2] == 1 || vexRT[Btn6U] == 1){
		motor[claw] = 127; //this closes claw
	}
	else if(vexRT[Btn6DXmtr2] == 1 || vexRT[Btn6D] == 1){
		motor[claw] = -127; //this opens claw
	}
	else{
		motor[claw] = 0;
	}
}

//==================================================================================================
//                             D R I V E   C O N T R O L L E R   S E C T I O N
//==================================================================================================

void allOff(){
	motor[leftMotors] = 0;
	motor[rightMotors] = 0;
}

void motorForward(){
	motor[leftMotors] = leftMotorsVal;
	motor[rightMotors] = rightMotorsVal;
	updatePowers();
	resetEncoders();
}

void motorBackward(){
	motor[leftMotors] = -leftMotorsVal;
	motor[rightMotors] = -rightMotorsVal;
	updatePowers();
	resetEncoders();
}

void motorLeftOn(){
	motor[leftMotors] = leftMotorsVal;
	motor[rightMotors] = 0;
}

void motorRightOn(){
	motor[leftMotors] = 0;
	motor[rightMotors] = rightMotorsVal;
}

void motorPointCC(){
	motor[leftMotors] = -leftMotorsVal;
	motor[rightMotors] = rightMotorsVal;
	updatePowers();
	resetEncoders();
}

void motorPointC(){
	motor[leftMotors] = leftMotorsVal;
	motor[rightMotors] = -rightMotorsVal;
	updatePowers();
	resetEncoders();
}

void driveFunct(int direction, int duration){
	for(int i = 0; i < duation; i = i + 1) {
		if(direction == 1){
			motorForward();
		}
		else if(direction == 2){
			motorBackward();
		}
		else if(direction == 3){
			motorLeftOn();
		}
		else if(direction == 4){
			motorRightOn();
		}
		else if(direction == 5){
			motorPointC();
		}
		else if(direction == 6){
			motorPointCC();
		}
		else if(direction == 7){
			motor[lifters] = 127;
		}
		else if(direction == 8){
			motor[lifters] = -127;
		}
		else if(direction == 9){
			motor[leftArm] = 127;
			motor[rightArm] = 127;
		}
		else if(direction == 10){
			motor[leftArm] = -127;
			motor[rightArm] = -127;
		}
		else{

		}
		wait1Msec(1);
	}
}

//==================================================================================================
//                             E N C O D E R   C O N T R O L L E R   S E C T I O N
//==================================================================================================

void resetEncoders() { //reset both encoder values
	SensorValue[RightBottomEnc] = 0;
	SensorValue[LeftBottomEnc] = 0;
}

void updatePowers() {
	int cp = 7; //estimated corrective proportion, translates the offset of encoder values into the amount of power a motor needs to adjust
	int right = abs(SensorValue[RightBottomEnc]); //absolute value of right encoder
	int left = abs(SensorValue[LeftBottomEnc]); //absolute value of left encoder
	if(right > left) {
		//if the right motor is overpowered
		//decrease right motor power by the difference in encoder values times cp
		leftMotorsVal = 127;
		if(rightMotorsVal > 10+(int)(cp*(right - left))) {
			rightMotorsVal = rightMotorsVal - (int)(cp*(right - left));
		}
	}
	else if(right < left){
		//if the left motor is overpowered
		//decrease left motor power by the difference in encoder values times cp
		rightMotorsVal = 127;
		if(rightMotorsVal > 10+(int)(cp*(left - right))) {
			leftMotorsVal = leftMotorsVal - (int)(cp*(left - right));
		}
	}
	//if the motors are of equal strength, motor powers don't change
}

void driveUntil(int right, int left) { //target number of ticks from right and left encoder
	int curRight = 0; //total number of ticks from right encoder
	int curLeft = 0; //total number of ticks from left encoder
	while(abs(curRight) < abs(right) || abs(curLeft) < abs(left)) { //while target numbers are not met
		updatePowers();
		if(abs(curRight) < abs(right)) { 
			//if right target is not met
			//turn the motor on certain direction to reach target value
			if(right > 0) {
				motor[rightMotors] = rightMotorsVal;
			}
			else if(right < 0) {
				motor[rightMotors] = -rightMotorsVal;
			}
			else {
				motor[rightMotors] = 0;
			}
		}
		else {
			motor[rightMotors] = 0;
		}
		if(abs(curLeft) < abs(left)) {
			//if left target is not met
			//turn the motor on certain direction to reach target value
			if(left > 0) {
				motor[leftMotors] = leftMotorsVal;
			}
			else if(left < 0) {
				motor[leftMotors] = -leftMotorsVal;
			}
			else {
				motor[leftMotors] = 0;
			}
		}
		else {
			motor[leftMotors] = 0;
		}
		//update current number of ticks before resetting encoders
		curRight = curRight + SensorValue[RightBottomEnc];
		curLeft = curLeft + SensorValue[LeftBottomEnc];
		resetEncoders();
	}
	allOff();
}

int abs(int n) { //absolute value function
	if(n < 0) {
		return n * -1;
	}
	else {
		return n;
	}
}

//==================================================================================================
//                      A U T O N O M O U S   C O N T R O L L E R   S E C T I O N
//==================================================================================================

void compAuton() {
	setupAuton();
	//---DRIVE UNTIL PROXIMITY ALLOWS FOR CONE DROP---//
	driveUntil(930,930);
	//---LOWER ELBOW---//
	motor[elbow] = -127;
	wait1Msec(1250);
	motor[elbow] = 0;
	//---DROP CONE---//
	motor[claw] = -127;
	wait1Msec(1500);
	motor[claw] = 0;
	//---RAISE CLAW---//
	motor[elbow] = 127;
	wait1Msec(1250);
	motor[elbow] = 0;
	//---ENSURE LIFTERS ARE LOWERED---//
	while(SensorValue[leftLiftSensor] > 940 || SensorValue[rightLiftSensor] > 2550) {
		motor[lifters] = -127;
	}
	motor[lifters] = 0;
	//---MOVE FORWARD TO PICK LIFT UP---//
	driveUntil(200,200);
	//---RAISE LIFTERS---//
	while(SensorValue[leftLiftSensor] < 2240 || SensorValue[rightLiftSensor] < 4050) {
		motor[lifters] = 127;
	}
	motor[lifters] = 0;
	//---DRIVE BACK---//
	driveUntil(-1100,-1100);
}

void skillsAuton() {
	setupAuton();
	motor[rightMotors] = 127;
	wait1Msec(0100);
	motor[rightMotors] = 100;
	motor[leftMotors] = 127;
	wait1Msec(1500);
	motor[lifters] = 127;
	motor[rightMotors] = 0;
	motor[leftMotors] = 0;
	wait1Msec(1200);
	motor[lifters] = 0;
	motor[rightMotors] = 127;
	motor[leftMotors] = -127;
	wait1Msec(1100);
	motor[rightMotors] = 100;
	motor[leftMotors] = 127;
	wait1Msec(1600);

	motor[lifters] = -127;
	motor[rightMotors] = 0;
	motor[leftMotors] = 0;
	wait1Msec(1200);
	motor[lifters] = 0;
	motor[rightMotors] = -127;
	motor[leftMotors] = -127;
	wait1Msec(0500);
	motor[lifters] = 127;
	motor[rightMotors] = 0;
	motor[leftMotors] = 0;
	wait1Msec(1000);
	motor[lifters] = 0;
	motor[leftMotors] = -127;
	motor[rightMotors] = -127;
	wait1Msec(1000);
	allOff();
}

void setupAuton() { 
	resetEncoders();
	//---EXTEND LIFTERS---//
	while(SensorValue[leftLiftSensor] > 940 || SensorValue[rightLiftSensor] > 2550) { 
		//while lifters are not fully extended, extend lifters
		motor[lifters] = -127;
	}
	motor[lifters] = 0;
	//---RAISE ARM TO ALLOW ELBOW TO EXTEND---//
	motor[rightArm] = 127; 
	motor[leftArm] = 127;
	wait1Msec(1000);
	motor[rightArm] = 0;
	motor[leftArm] = 0;
	//---RAISE ELBOW AND ARM TO MAXIMUM---//
	//needs changing, too slow -- no need to extend to maximum, use times instead
	while(SensorValue[ArmLimit] == 0 || SensorValue[ElbowLimit] == 0) {
		if(SensorValue[ArmLimit] == 0) {
			motor[leftArm] = 127;
			motor[rightArm] = 127;
		}
		else {
			motor[rightArm] = 0;
			motor[leftArm] = 0;
		}
		if(SensorValue[ElbowLimit] == 0) {
				motor[elbow] = 127;
		}
		else {
			motor[elbow] = 0;
		}
	}
	//---LOWER ARM---//
	motor[rightArm] = -127;
	motor[leftArm] = -127;
	wait1Msec(1000);
	motor[rightArm] = 0;
	motor[leftArm] = 0;
	motor[rightArm] = 127;
	motor[leftArm] = 127;
	wait1Msec(200);
	motor[rightArm] = 0;
	motor[leftArm] = 0;
}
